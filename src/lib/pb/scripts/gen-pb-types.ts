import { runCommand } from "@/utils/fs";
import { config as dotenvConfig } from "dotenv";
dotenvConfig(); 
import { writeFile, readFile } from "node:fs/promises";
const CUSTOM_DB_TYPES_PATH = "./src/lib/pb/custom-db-types.ts";


const CHUNKED_TYPES_OUTPUT_DIR = "./src/lib/pb/pb-types.ts";

export async function getCustomTypes() {
  const custom_db_types_string = await readFile(CUSTOM_DB_TYPES_PATH, "utf-8");

  let extracted_custom_db_types = "";
  const extracted_custom_db_types_array: {
    target_interface: string;
    field: string;
    new_custom_type: string;
  }[] = [];
  const custom_db_types_lines = custom_db_types_string.split("\n");
  //   const custom_type_start = custom_db_types_lines.findIndex((line) =>line.includes("custom_db_types"));
  for (const [index, line] of custom_db_types_lines.entries()) {
    if (line.includes("=== start of custom type ===")) {
      // @ts-expect-error
      const custom_block_hint = custom_db_types_lines?.[index + 1]
        .trim()
        .split(".");

      const sub_custom_db_types_lines = custom_db_types_lines.slice(index);
      // console.log("= sub custom type lines ", sub_custom_db_types_lines);
      const custom_block_end = sub_custom_db_types_lines.findIndex((line) =>
        line.includes("=== end of custom type ==="),
      );
      //   console.log("= custom block end ", custom_block_end);
      const custom_type_in_block = sub_custom_db_types_lines.slice(
        2,
        custom_block_end,
      );
      extracted_custom_db_types += `${custom_type_in_block.join("\n")}\n`;
      // @ts-expect-error
      const target_interface_prefix = custom_block_hint?.[0]
        .replace("//", "")
        .trim();
      extracted_custom_db_types_array.push({
        target_interface: `${target_interface_prefix}Create`,
        field: `${custom_block_hint[2]}`,
        // @ts-expect-error
        new_custom_type: custom_block_hint[1],
      });
      extracted_custom_db_types_array.push({
        target_interface: `${target_interface_prefix}Update`,
        field: `${custom_block_hint[2]}`,
        // @ts-expect-error
        new_custom_type: custom_block_hint[1],
      });
      extracted_custom_db_types_array.push({
        target_interface: `${target_interface_prefix}Response`,
        field: `${custom_block_hint[2]}`,
        // @ts-expect-error
        new_custom_type: custom_block_hint[1],
      });
    }
  }
  return {
    extracted_custom_db_types,
    extracted_custom_db_types_array,
  };
}

export async function getPBType() {
  const PB_ADMIN_EMAIL = process.env.PB_ADMIN_EMAIL;
  const PB_ADMIN_PASSWORD = process.env.PB_ADMIN_PASSWORD;
  const PB_URL = process.env.VITE_PB_URL;

  const commands = [
    "npx",
    "@tigawanna/typed-pocketbase",
    "--email",
    PB_ADMIN_EMAIL,
    "--password",
    PB_ADMIN_PASSWORD,

  ];
  if(PB_URL){
    commands.push("--url", PB_URL);
  }
  console.log(" ================ running command =============== ", commands);
  const output = await runCommand(commands.join(" "));
  return output;
}

export async function modifyAndInjectCustomSTypes(content: string) {
  const { extracted_custom_db_types, extracted_custom_db_types_array } =
    await getCustomTypes();
  const content_array = content.split("\n");
  for (const [
    idx,
    { target_interface, field, new_custom_type },
  ] of extracted_custom_db_types_array.entries()) {
    for (const [index, target] of content_array.entries()) {
      if (target.includes(target_interface)) {
        const target_index = content_array.findIndex((line, idx) => {
          return line.includes(field) && idx > index;
        });

        if (target_index && target_index > 0) {
          content_array.splice(
            target_index,
            1,
            `\t${field}?: ${new_custom_type}`,
          );
        }
      }
    }
  }
  const new_content_string = `${extracted_custom_db_types}\n${content_array.join("\n")}`;
  // console.log(" === content after  ==== ",new_content_string)
  return new_content_string;
}

// cli util to filter out the types generated by typed pocektbase by the provided collection
export async function filterByCollection() {
  const collection = process.argv[2];
  if (!collection) {
    throw new Error("Please provide a collection name");
  }
  try {
    let text_output = "";
    let currentBlock: string | null = null;
    let first_block_index = 0;
    let current_block_indexes = [0, 0];
    const all_block_indexes: { [key: string]: number[] } = {};

    // const file_string = await readFile(TYPES_OUTPUT_PATH, "utf-8");
    const file_string = await getPBType();
    const lines = file_string.split("\n");
    for (const [index, line] of lines.entries()) {
      if (currentBlock) {
        // mark the end current block if at the end of the file
        if (lines.length - 1 === index) {
          current_block_indexes[1] = index;
          all_block_indexes[currentBlock] = [...current_block_indexes];
        }
      }
      if (line.startsWith("// ===== ")) {
        const current_block_name = line?.split("=====")[1]?.trim();
        // currentBlck is not null after the first // ===== encount eredor a new block
        if (currentBlock) {
          // current block is not the same as the current block name
          if (currentBlock !== current_block_name) {
            // mark where the currennt block index ends at
            current_block_indexes[1] = index;
            // save the current block index to the all_block_indexes
            all_block_indexes[currentBlock] = [...current_block_indexes];
          }
          //   nullify the current block name to start the new one
          currentBlock = null;
        }
        // current block is null after the first // ===== encount eredor a new block
        if (!currentBlock) {
          // mark where the first // ===== block index is encountered ,this will be used to determine where the glbal/shared types end
          if (Object.entries(all_block_indexes).length === 0) {
            first_block_index = index;
          }
          // mark where the currennt block index starts at
          current_block_indexes[0] = index;
          //   set the current block name
          // @ts-expect-error
          currentBlock = current_block_name;
        }
      }
    }
    //  add init types ( shared pocketbase types )
    const init_types = lines.slice(0, first_block_index);
    text_output = init_types.join("\n");
    //  Main types section
    for (const [key, value] of Object.entries(all_block_indexes)) {
      // filter inly for specified collection
      if (!key.includes(collection)) continue;
      const selected_lines = lines.slice(value[0], value[1]);
      selected_lines.splice(0, 1, `// ==== start of ${key} block =====\n`);
      selected_lines.push(`// ==== end of ${key} block =====\n`);
      const data = selected_lines.join("\n");
      //   concatenate the selected lines
      text_output += `${data}\n`;
    }
    //  add the final schema block
    const schema_block = all_block_indexes.Schema;
    // filter only for specified collection
    if (schema_block) {
      const schema_lines = lines.slice(schema_block[0], schema_block[1]);
      const filtered_schema_lines = [];
      for (const line of schema_lines) {
        if (line.includes(collection)) {
          filtered_schema_lines.push(line);
        }
        if (line.includes("{") || line.includes("}")) {
          filtered_schema_lines.push(line);
        }
      }
      text_output += filtered_schema_lines.join("\n");
    }

    // insert custon types in src\lib\pb\custom-db-types.ts
    // ensure we have custom types in src\lib\pb\custom-db-types.ts
    const modified_custom_db_types =
      await modifyAndInjectCustomSTypes(text_output);

    await writeFile(
      CHUNKED_TYPES_OUTPUT_DIR,
      modified_custom_db_types,
      "utf-8",
    );
    return { text_output, all_block_indexes, first_block_index };
  } catch (error) {
    // biome-ignore lint/complexity/noUselessCatch: <explanation>
    throw error;
  }
}

filterByCollection()
  .then((res) => {
    console.log("===== succesfull types generation ==== ");
  })
  .catch((err) => {
    console.log("===== error types generation ==== ", err);
  });
